# 陣列

前一張在介紹迴圈時，提到一些例子，例如我有一百件褲子，要一件一件檢查。或是老師巡邏學校有好幾個班級。我們知道可以用迴圈的方式，一個一個把「東西」數過一遍，也就是遍歷一次，但迴圈是「方法」，我們必須準備好東西，才能使用方法。

這邊的東西就是指一百件褲子或是 20 個班級。我們需要用一個容器來儲存這些東西，在 JS 中，這個容器可以是陣列（Array），我們可以把一百件褲子放入陣列，那他就會叫做褲子陣列。

事實上可以存一堆物品的容器可以是其他東西，但我們晚點再介紹。這個章節中我們要介紹何謂陣列。

## 定義

這邊先定義陣列：讓東西以連續的方式放入長條形容器。

就像下面這張圖一樣：

糖果盒： ![array 1](img/array1.png)

在這個例子中，我們有好多顆糖果，然後我們把糖果一顆一顆放進長條形盒子裡，這個概念就是陣列了！

JS 的陣列可以放入任何東西，而且可以是不同東西。例如陣列可以混雜放入數字、字母、物件（Object）甚至是函數（function）。

雖然說可以混雜放入不一樣東西，但是我們習慣上會讓陣列放入同一種物品，例如全部都是數字，全部都是字串。這是因為在 C++、Java 等語言中，陣列只能是同型別的物件，你必須在使用陣列前就先跟程式說好這個陣列只會裝什麼。所以 JS 可以隨便放其實是一種雙面刃，有很大彈性，也有很大的風險。

要注意的是，陣列的每個元素都會有編號，編號會從 0 開始數起，依序往後加一。像這邊有四顆糖果，所以糖果編號是 0、1、2、3。之後我們要呼叫特定糖果時，就會需要這個編號。

## JS 語法

### 建立陣列

如果我們想要定義一個陣列，我們可以這樣宣告：

```js
let primes = [2, 3, 5, 7, 11, 13, 17];
```

這邊我把質數放入陣列中，我們觀察到陣列的語法是：

```js
let 某陣列 = [元素0, 元素1, 元素2, ... ];
```

## 呼叫元素

!FILENAME ex1.js

```js
const primes = [2, 3, 5, 7, 11, 13, 17];
console.log(primes);
console.log(typeof(primes));
console.log(primes[0])
console.log(primes[1])
```

執行 `ex1.js`：

```log
$ node ex1.js
[ 2, 3, 5, 7, 11, 13, 17 ]
object
2
3
```

- 第一行我們先印出原本的陣列，發現跟原本一樣（不是廢話？XD）其實是跟大家說以後要 debug 時可以直接印出來看。
- 第二行我們檢查 `primes` 的型別，發現竟然是 `object`（物件），非常神奇！這其實是因為陣列在 JS 中被歸類成「特殊的」物件。不過我們心中要知道他就是陣列。
- 第三行我呼叫了 `primes[0]`，這是取得 `primes` 陣列中第 0 個元素的意思。因為編號是從左數到右，所以編號 0 的元素就是 `2`。
- 第四行我呼叫了 `primes[1]`，所以從左第二個元素 `3` 會被印出來。

所以我們知道如果想要存取陣列的某個元素，我們可以用 `陣列名稱[編號]` 來取得那個物件。

### 修改陣列

我們知道可以用 `陣列名稱[編號]` 來取得特定元素，我們除了可以去讀他的值，當然也可以修改他。

!FILENAME ex2.js

```js
const names = ["Jenny", "Tiger", "Leo"];
console.log(names);

names[0] = "Lucy";
console.log(names);
```

執行 `ex2.js`：

```log
$ node ex2.js
[ 'Jenny', 'Tiger', 'Leo' ]
[ 'Lucy', 'Tiger', 'Leo' ]
```

我們先印出原本的陣列，然後修改第 0 個元素，再印出一次，發現元素的確被更換了！

當然我們也可以直接把原本陣列換掉。

!FILENAME ex3.js

```js
let names = ["Jenny", "Tiger", "Leo"];
console.log(names);

names = ["Cat", "Dog"];
console.log(names);
```

執行 `ex3.js`：

```log
$ node ex2.js
[ 'Jenny', 'Tiger', 'Leo' ]
[ 'Cat', 'Dog' ]
```

陣列就直接被替換掉了。

這邊要注意，我們之前有提到 `const` 定義不變的變數，`let` 定義會變的變數。在陣列中，除非你把**整個陣列換成另一個陣列**，不然視為不變。換句話說，`let` 才能對整個陣列本身做改動，不然用 `const` 就可以了。

舉個例子說明：

```js
const names = ["Jenny", "Tiger", "Leo"];
names = ["Cat", "Dog"]; // 錯誤，不可直接替換成另一個陣列
names[0] = ["Meow"]; // 可以，因為對元素操作，不算改變陣列本身
```

## 混搭

剛剛提過，JS 中的陣列很特別，可以放入各種東西混在一起。

```js
const names = ["Jenny", true, 3444, 6.7];
```

### 陣列操作

假設今天班上有 40 個學生，今天來了一個轉學生。我們會把原本班級打散，重新組一個班級嗎？當然不會。我們只要多準備一套桌椅給他就好。

所以假設今天有陣列：

```js
const numbers = [1, 2, 3];
```

如果今天我想加一個元素進陣列，我們也不必重新定義陣列，只要插入元素即可。同理，我們也可以直接移除一個元素。

!FILENAME ex4.js

```js
const names = ["A", "B"];
console.log(names); // 列印原本

names.push("D"); // 向後插入
console.log(names);

names.pop();  // 移除最後面一個
console.log(names);

names.shift(); // 移除最前面一個
console.log(names);

names.unshift("K"); // 從前插入
console.log(names);
```

執行 `ex4.js`：

```log
$ node ex2.js
[ 'A', 'B' ]
[ 'A', 'B', 'D' ]
[ 'A', 'B' ]
[ 'B' ]
[ 'K', 'B' ]
```

- `push(元素)` 是把元素插入陣列最後面的方法
- `pop()` 會把陣列中最後一個元素移除
- `shift()` 會把陣列中最前面一個元素移除
- `unshift(元素)` 是把元素插入到陣列最前面的方法

在這幾個方式操作下，陣列本身並沒有改變，如同我剛剛形容班級，班級並不會因為一個學生轉走轉入而必須打散重組，所以我們可以用 `const` 定義陣列，並增加和移除元素。
